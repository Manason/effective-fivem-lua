{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Foreword","text":"<p>As I've forayed into the FiveM modding community, I've observed many different styles and strategies for writing Lua code. Some of these lead to code that is easy to maintain, read, and understand; while others result in code that is confusing, buggy, and less performant.</p> <p>I've also learned of many behaviors specific to FiveM, or the Lua language itself, which suggest preferring certain functions over others.</p> <p>I want to collect these best practices from Lua and FiveM, combined with my knowledge of clean code practices from the broader software community, within this handbook. This documentation is meant to be immediately useful and concrete, with plenty of examples of what to do, and what not to do.</p> <p>However, a disclaimer; This work represents the best of my knowledge for writing effective Lua code for the GTA 5 FiveM framework. Thus, the limits of my knowledge are also reflected in this work. If I have made a mistake, please let me know.</p> <p>- Manason</p>"},{"location":"conditionals/","title":"Conditionals","text":""},{"location":"conditionals/#default-values","title":"Default Values","text":"<p>Consider ternary operator 'or' instead of nil checks to improve readability. BAD<pre><code>if name then\n    return name\nelse\n    return \"John Doe\"\nend\n</code></pre> GOOD<pre><code>return name or \"John Doe\"\n</code></pre></p>"},{"location":"conditionals/#dont-write-if-true-then-return-true","title":"Don't Write \"if true then return true\"","text":"<p>When returning or setting a variable to the value of the conditional statement itself, don't use an if else block. BAD<pre><code>if name == \"mark\" or name == \"stacy\" then\n   return true\nelse\n   return false\nend\n</code></pre> GOOD<pre><code>return name == \"mark\" or name == \"stacy\"\n</code></pre></p>"},{"location":"conditionals/#prefer-positive-boolean-expressions","title":"Prefer positive boolean expressions","text":"<p>This makes the code easier to read. BAD<pre><code>if not isHappy then\n  return \"sad\"\nelse\n  return \"happy\"\nend\n</code></pre> GOOD<pre><code>if isHappy then\n  return \"happy\"\nelse\n  return \"sad\"\nend\n</code></pre></p>"},{"location":"errors/","title":"Error Handling","text":"<p>An unexpected state or condition within the code may cause a lua error to be thrown. However, these bad states can have other consequences when not so explicitly detected and handled. They may propagate bad state to other components of the system, or introduce unintended behavior. Checking for and handling unexpected state can make your code more robust to possibile failures and vulnerabilities.</p>"},{"location":"errors/#use-assert-instead-of-if-expression-then-error","title":"Use assert instead of 'if expression then error()'","text":"<p>assert is a more succinct, readable way to throw an error on a condition not being met</p> <p>BAD<pre><code>if not someVar then error(\"someVar is nil\") end\n</code></pre> GOOD<pre><code>assert(someVar ~= nil, \"someVar is nil\")\n</code></pre></p>"},{"location":"errors/#pre-condition-check-liberally","title":"Pre-condition check liberally","text":"<p>When performing an operation, make a list of assumptions and then write pre-condition checks.</p>"},{"location":"errors/#fail-loudly-for-unexpected-state","title":"Fail loudly for unexpected state","text":"<p>When writing pre-condition checks, failure should often result in a lua error with a message. Failing silently by just early returning from a function can be difficult to debug and may go undetected.</p> <p>BAD<pre><code>if not isPlayerDead() then return end\n</code></pre> GOOD<pre><code>assert(isPlayerDead(), \"player is not dead\")\n</code></pre></p>"},{"location":"errors/#throwing-an-error-vs-logging","title":"Throwing an Error vs Logging","text":"<p>Some states may be unexpected, but recoverable. In these cases, it may be preferable to log the state, but still allow the operation to proceed. An example of this would be a player selling items to an NPC. If some of the items were failing to sell, it would be better to log/print the error, while allowing the rest of the items to go through.</p> <p>Keep in mind what execution will be cancelled by throwing an error and use best judgment to decide whether throwing or logging is the better choice.</p>"},{"location":"errors/#assertions-vs-errors-as-values","title":"Assertions vs Errors as Values","text":"<p>Assertions cause lua errors to propagate up the stack, forcing callers to handle them via protected calls. While assertions should always be used for unexpected or \"impossible\" cases, errors as values can be helpful for expected failure cases that we want the caller of the API to handle. This involves returning a success boolean, followed by an optional error code &amp; message. Doing this makes the default behavior of our function fail silently, as it becomes the callers responsibility to decide to handle the error. This can provide a better experience for players as a silent failure may preferable to loud error messages in cases where the player pressed the wrong button for example.</p> <p>Note that API functions should be idempotent when possible. A no-op result is still considered successful, if the state of the system is the one the caller expects after the function is ran.</p>"},{"location":"errors/#example-error-as-value","title":"Example Error as Value","text":"<pre><code>function add(a, b)\n    if not a or not b then\n        return nil, {\n            code = 'missing_required_params',\n            message = 'either a or b is nil',\n        }\n    end\n    return a + b\nend\n</code></pre>"},{"location":"events/","title":"Events","text":""},{"location":"events/#naming","title":"Naming","text":"<p>Event names should be in the form '{resourceName}:{client/server}:{eventName}' This allows the reader to tell at a glance what resource the event is triggered from, and whether the event should be handled on the client or server.</p>"},{"location":"events/#past-tense","title":"Past Tense","text":"<p>An event should describe something that has already happened, without prescribing the desired reaction. This pattern recognizes that many event handlers may exist for the same event, which each handle the event in a different way. Triggering an event should be thought of as the cause, whereas handling an event is the effect. The effect should not be in the event name. While an event name need not strictly be past tense, writing event names using past tense can help developers follow this principle.</p> <p>BAD<pre><code>local function sendMessage(message)\n    TriggerEvent('resourceName:server:checkProfanity', message)\nend\n\nRegisterNetEvent('resourceName:server:checkProfanity', source, message)\n    checkProfanity(message)\nend\n</code></pre> GOOD<pre><code>local function sendMessage(message)\n    TriggerEvent('resourceName:server:sentMessage', message)\nend\n\nRegisterNetEvent('resourceName:server:sentMessage', source, message)\n    checkProfanity(message)\nend\n</code></pre></p>"},{"location":"events/#use-callbacks-when-wanting-to-get-data-back-across-the-network","title":"Use callbacks when wanting to get data back across the network","text":"<p>It's an anti-pattern to trigger and listen for a separate event to get data back across the network when triggering an event. Instead, use a callback.</p>"},{"location":"events/#use-a-function-instead-of-an-event-handler-for-single-resource-non-networked-events","title":"Use a function instead of an event handler for single resource, non-networked events","text":"<p>Events differ from functions in that one event can have many handler functions, versus a function call only executes one function. If the event is non-networked and only is intended to be handled by one resource, a function should be used instead.</p>"},{"location":"events/#use-addeventhandler-for-non-networked-events","title":"Use AddEventHandler for non-networked events","text":"<p>Keeping with the principle of limiting scope, if an event is triggered and handled on the client or server exclusively, do not register it as a net event.</p>"},{"location":"events/#secure-net-events","title":"Secure Net Events","text":"<p>GetInvokingResource will be nil if an event is triggered from the opposite side of the network that the event is registered on (client triggering a server event, or server triggering a client event). Restrict other ways to call the event to prevent exploits, unless the event is intended to be triggered by both the client and server. <pre><code>RegisterNetEvent('resourceName:client:eventName', function()\n    if GetInvokingResource() then return end\n    --- handle the event\nend)\n</code></pre></p>"},{"location":"functions/","title":"Functions","text":""},{"location":"functions/#size-scope","title":"Size &amp; Scope","text":"<ul> <li>Functions should only do one thing, and should be small. If a function is not small, break it up into smaller functions.</li> <li>Avoid mixing high level code with low level code in the same function.</li> </ul>"},{"location":"functions/#naming","title":"Naming","text":"<ul> <li>Local functions should be named in camelCase format to differentiate from natives and standard lua library functions</li> <li>Global functions should be named in PascalCase format</li> <li>Functions should also be named with a leading verb.</li> </ul> <p>BAD<pre><code>function player()\nfunction playerDrop()\n</code></pre> GOOD<pre><code>function getPlayerObject()\nfunction dropPlayer()\n</code></pre></p>"},{"location":"functions/#parameters","title":"Parameters","text":""},{"location":"functions/#limit-number-of-parameters","title":"Limit Number of Parameters","text":"<p>If needing more than 3 or so parameters for a single function, that may be a sign that the parameters can be grouped within a table and passed as a object, rather than as individual arguments. BAD<pre><code>function createChar(name, age, height, birthday, nationality)\n\nend\n</code></pre> GOOD<pre><code>function createChar(char)\n\nend\n</code></pre></p>"},{"location":"functions/#avoid-boolean-parameters-in-apis","title":"Avoid boolean parameters in APIs","text":"<p>Boolean parameters are a signal that a function is doing two things. Instead, call two different functions that each do one thing. While what is considered an API is ambiguous, a good rule of thumb is not to include boolean parameters in global or exported functions. BAD<pre><code>function PrintEmotionalState(isHappy)\n    if isHappy then\n        print(\"happy\")\n    else\n        print(\"sad\")\n    end\nend\n</code></pre> GOOD<pre><code>function PrintHappy()\n    print(\"happy\")\nend\n\nfunction PrintSad()\n    print(\"sad\")\nend\n</code></pre></p>"},{"location":"functions/#avoid-passing-implied-functions-as-arguments","title":"Avoid passing implied functions as arguments","text":"<p>Instead declare the function in a local variable and pass the variable as the argument. This has major performance improvements if the calling function is invoked more than once. Some functions such as CreateThread are often only invoked once, so there wouldn't be any performance improvement to localizing the argument function. However, I still recommend it anyway as a defensive measure to avoid the issue entirely if the code were to change in the future.</p> <p>BAD<pre><code>someFunction(function()\n\nend)\n</code></pre> GOOD<pre><code>local function myFunction()\n\nend\nsomeFunction(myFunction)\n</code></pre></p>"},{"location":"functions/#parameter-overloads","title":"Parameter Overloads","text":"<p>Be careful overloading a function. Overloading can be a smell that a function is doing more than one thing. Overloads are useful as wrapper functions, providing different ways to call the same underlying function.</p>"},{"location":"functions/#optional-parameters","title":"Optional Parameters","text":"<p>Required parameters should come before optional ones.</p>"},{"location":"functions/#export-documentation","title":"Export Documentation","text":"<p>Exports should have a lua-language-server annotation to delare the API <pre><code>--- Puts a space between a first and last name\n---@param first string first name\n---@param last string last name\n---@return string full name\nlocal function formatName(first, last)\n    return first .. ' ' .. last\nend\n\nexports('formatName', formatName)\n</code></pre></p>"},{"location":"functions/#keep-returned-values-small-in-size","title":"Keep returned values small in size","text":"<p>Since returned values are passed-by-value, there can be a sigificant performance cost to returning large payloads. Benchmarks show it is more performant to have many export calls that return a small amount of data each, than few export calls that return large payloads, even if the total number of bytes transferred is the same. Providing accessor exports instead of direct access to tables also makes your API more flexible to future changes.</p> <p>BAD<pre><code>exports('GetTable', function()\n    return myTable\nend)\n</code></pre> GOOD<pre><code>exports('GetValue', function(key)\n    return myTable[key]\nend)\n</code></pre></p>"},{"location":"functions/#use-guard-clauses","title":"Use guard clauses","text":"<p>Often before doing the \"real\" work of a function, certain pre-conditions must be met. Guard clauses are conditional statements that provide early returns to check certain conditions. This allows the reader to also exit early, rather than reading the entire function.</p> <p>Additionally, using guard clauses avoids nesting, which can make code difficult to read. Sometimes though, a simple if statement reads just fine. Use your best judgment. BAD<pre><code>local function getFullName(first, last)\n    if not nameHidden and first and last then\n        return first .. last\n    else\n        return nil\n    end\nend\n</code></pre> GOOD<pre><code>local function getFullName(first, last)\n    if nameHidden then return end\n    if not first or not last then return end\n    return first .. last\nend\n</code></pre></p>"},{"location":"natives/","title":"Natives","text":""},{"location":"natives/#remove-citizen-prefix-where-possible","title":"Remove Citizen. prefix where possible","text":"<p>BAD<pre><code>Citizen.Wait()\nCitizen.CreateThread()\nCitizen.SetTimeout()\n</code></pre> GOOD<pre><code>Wait()\nCreateThread()\nSetTimeout()\n</code></pre></p>"},{"location":"natives/#do-not-use-gethashkey","title":"Do not use GetHashKey()","text":""},{"location":"natives/#replace-string-hashes-with-backticks","title":"Replace string hashes with backticks","text":"<p>BAD<pre><code>local hashKey = GetHashKey('hash')\n</code></pre> GOOD<pre><code>local hashKey = `hash`\n</code></pre></p>"},{"location":"natives/#replace-gethashkeyvariable-with-joaatvariable","title":"Replace GetHashKey(variable) with joaat(variable)","text":"<p>BAD<pre><code>local hashKey = GetHashKey(myHash)\n</code></pre> GOOD<pre><code>local hashKey = joaat(myHash)\n</code></pre></p>"},{"location":"natives/#use-vector3-math-rather-than-getdistancebetweencoords","title":"Use Vector3 math rather than GetDistanceBetweenCoords()","text":"<p>BAD<pre><code>local distance = GetDistanceBetweenCoords(1, 1, 1, 0, 0, 0)\n</code></pre> GOOD<pre><code>local coord1 = vector3(1, 1, 1)\nlocal coord2 = vector3(0, 0, 0)\nlocal distance = #(coord1 - coord2)\n</code></pre></p>"},{"location":"natives/#use-playerpedid-instead-of-getplayerped-1","title":"Use PlayerPedId() instead of GetPlayerPed(-1)","text":"<p>BAD<pre><code>local playerPed = GetPlayerPed(-1)\n</code></pre> GOOD<pre><code>local playerPed = PlayerPedId()\n</code></pre></p>"},{"location":"structure/","title":"Structure/Scope","text":""},{"location":"structure/#prefer-limited-scope","title":"Prefer Limited Scope","text":"<p>Variables and functions should be scoped to the smallest visibility needed. Prefer in order, local function, function, export function, AddEventHandler, RegisterNetEvent/Callback</p>"},{"location":"structure/#separate-client-server-files","title":"Separate Client &amp; Server Files","text":"<p>Client and server specific files should be organized into their own folders</p>"},{"location":"structure/#use-logical-grouping","title":"Use Logical Grouping","text":"<p>It may make sense to place constructs of the same type together in a file. For example, all file scoped variables at the top of the file, followed by all local functions, followed by all global functions, followed by events. This grouping structure makes it easier to understand the API at the server, resource, and file levels. Alternatively, local single use functions could be located directly above or as close as possible to the functions they are called from, and grouping can be based on call structure rather than construct type.</p>"},{"location":"structure/#use-filesmodules-to-hide-local-functions","title":"Use Files/Modules To Hide Local Functions","text":"<p>If you have one resource scoped function which calls a few local single use functions, put them all in their own file or module.</p>"},{"location":"structure/#resource-naming","title":"Resource Naming","text":"<p>Resources should be named with underscores \"_\" instead of spaces. Other special characters should be avoided so that exports work well.</p>"},{"location":"structure/#file-naming","title":"File Naming","text":"<p>Files should be named all lower case without any spaces. dashes \"-\" or underscores \"_\" can be used instead of spaces.</p>"},{"location":"tables/","title":"Tables","text":""},{"location":"tables/#imply-array-indices","title":"Imply Array Indices","text":"<p>Other languages don't allow declaring an array with explicit indices. Unless the keys have important meaning that needs to be made clear to the reader, they should be implied. BAD<pre><code>local myTable = {\n    [1] = \"first index\",\n    [2] = \"second index\",\n    [3] = \"third index\"\n}\n</code></pre></p> GOOD<pre><code>local myTable = {\n    \"first index\",\n    \"second index\",\n    \"third index\"\n}\n</code></pre>"},{"location":"tables/#dereferencing","title":"Dereferencing","text":""},{"location":"tables/#prefer-object-access-for-constant-keys-and-array-access-for-non-constant-keys","title":"Prefer object access for constant keys, and array access for non-constant keys","text":"<p><pre><code>local company = {\n    boss = \"Sam\"\n}\n</code></pre> BAD<pre><code>local boss = company[\"boss\"]\n</code></pre> GOOD<pre><code>local boss = company.boss\n</code></pre></p>"},{"location":"tables/#extract-duplicate-table-dereferences-into-local-variables","title":"Extract duplicate table dereferences into local variables","text":"<p>This is both a readability and performance boost BAD<pre><code>local concatenation = myTable[\"key\"] .. myTable[\"key\"]\n</code></pre> GOOD<pre><code>local myTableValue = myTable[\"key\"]\nlocal concatenation = myTableValue .. myTableValue\n</code></pre></p>"},{"location":"tables/#avoid-tableinsert","title":"Avoid table.insert()","text":"<p>It has horrible performance. It should only be used if needing to insert into an array at a specific index that is not the last index.</p>"},{"location":"tables/#inserting-at-the-end-of-a-table","title":"Inserting at the end of a table","text":"<p>BAD<pre><code>table.insert(myTable, \"value\")\n</code></pre> GOOD<pre><code>myTable[#myTable + 1] = \"value\"\n</code></pre></p>"},{"location":"tables/#insertingoverwriting-a-given-key","title":"Inserting/Overwriting a given key","text":"<p>BAD<pre><code>table.insert(myTable, \"key\", \"value\")\n</code></pre> GOOD<pre><code>myTable[\"key\"] = \"value\"\n</code></pre></p>"},{"location":"tables/#use-numeric-for-loops-when-iterating-over-an-array","title":"Use numeric for loops when iterating over an array","text":"<p>This is a performance boost</p> <p>BAD<pre><code>for k, v in pairs(myArray) do\n    print(k .. \", \" .. v)\nend\n</code></pre> GOOD<pre><code>for i=1, #myArray do\n    print(i .. \", \" .. myArray[i])\nend\n</code></pre></p>"},{"location":"tables/#maintain-your-own-array-size-variable","title":"Maintain your own array size variable","text":"<p>There is a significant performance difference for large arrays as #array is an O(n) operation. Note that sometimes iterating through the the entire array to find the size is preferable, but a common pattern of starting with an empty array and populating it in a loop should use an array size variable.</p> <p>BAD<pre><code>for i = 1, 100 do\n  myArray[#myArray+1] = i\nend\n</code></pre> GOOD<pre><code>local myArraySize = 0\nfor i = 1, 100 do\n  myArraySize += 1\n  myArray[myArraySize] = i\nend\n</code></pre></p>"},{"location":"variables/","title":"Variables","text":""},{"location":"variables/#naming","title":"Naming","text":""},{"location":"variables/#name-constants-using-all_caps","title":"Name constants using ALL_CAPS","text":"<pre><code>local MY_CONSTANT = \"constant value\"\nMY_GLOBAL_CONSTANT = \"another constant value\"\n</code></pre>"},{"location":"variables/#camelcase-non-constant-local-variable-names","title":"camelCase non-constant local variable names","text":"<pre><code>local myVariable = \"variable value\"\n</code></pre>"},{"location":"variables/#pascalcase-non-constant-global-variable-names","title":"PascalCase non-constant global variable names","text":"<pre><code>MyGlobalVariable = \"global variable value\"\n</code></pre>"},{"location":"variables/#use-underscore-_-as-the-name-of-a-variable-that-cannot-be-deleted-but-is-unused","title":"Use underscore \"_\" as the name of a variable that cannot be deleted but is unused.","text":"<pre><code>local function printValues(map)\n    for _, v in pairs(map) do\n        print(v)\n    end\nend\n</code></pre>"},{"location":"variables/#enums-vs-booleans","title":"Enums Vs Booleans","text":"<p>Enums should be used to reflect the state of something when more than two options exist. A common anti-pattern is using multiple booleans to reflect the state. This is confusing and problematic, because the code then needs to defend against impossible states, as the combination fo booleans is able to represent more states than is desired. It also makes the code more opaque and harder to reason about. What does it mean if isWalking and isRunning are both false? That we don't know? Is the state is idle? Or maybe swimming?</p> <p>BAD<pre><code>local isWalking = false\nlocal isRunning = false\n</code></pre> GOOD<pre><code>local MOVEMENT = {\n    UNKNOWN = 1,\n    WALKING = 2,\n    RUNNING = 3\n}\nlocal movementState = MOVEMENT.UNKNOWN\n</code></pre> Representing the state in an enum this way also makes it easier to modify in the future to add more states. Such as idle, swimming, flying, falling, etc. Adding an UNKNOWN field is useful when the enum isn't exhaustive, as a catch all to represent any other state.</p>"},{"location":"variables/#location","title":"Location","text":"<p>Local variables within a function should be declared as close as possible to the place where they are used. This limits what the developer must keep in their head while reading the code. Local variables declared outside of a function should be declared at the top of the file, grouped together. Global variables should be declared at the top of the file grouped together. client/server global variables should only be declared within a single client/server file. This helps keep things organized instead of spreading random globals around the resource.</p>"}]}